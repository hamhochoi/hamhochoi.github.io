---
layout: post
title: "Week 5"
---

## WEEK 5: Image Segmentation

- Hough Transform: Line detection
- Ostu algorithms: 
  - Seperate background and foreground by using threshold to move part of histogram related to background.
  - Not work if there is much noise, so that histogram of background and foreground aren't seperated. Can handle this case, we can use denoise technique.
  - Assumption: In-class intensity are close, so we can seperate each class by seperate the histogram.
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/ostu_alg.png)
  
  - We try to minimize the weighted variance of ways of seperating the histogram. In which, t: threshold; q(t): probability of class 1 with threshold <=t, by sum up the probabilities of every pixel in this class; p(t): probability of class 2 with threshold >t, by sum up the probabilities of every pixel in this class. 
  - **Note**: If the background is note uniform, we cannot apply the ostu alg because the alg will mislead seperate the different part of the background.
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/ostu_3.png)
    - To handle this problem, we can apply ostu alg to sub-blocks of the image (non-overlapping/overlapping blocks).
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/ostu_4.png)
    
- Interactive Image Segmentation: 
  - Step 1: Ask user to indicate foreground and background. From this information, plot distribution of foreground, background; try to mark pixel have intensity likely with the foreground as foreground, likely with the background as background.  
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/img_segment_1.png)
  
  - Step 2: 
    - If we just rely on intensity, some pixels in foreground may have intensity closer to background distribution. To handle this issue, we compute weighted geodestic distance: For each pixel, compute the weighted distance between it to the background/foreground indicator (which we ask user to draw, and called 'scrible'), then classify that pixel to the closer class.
    1. Compute the probability for each pixel by the formula in step 1
    2. For each pixel, compute the distance from each pixel to every pixel on the scribles of background and foreground. 
    3. At each pixel, if the smallest cost of going from it to the background > the smallest cost of going from it to foreground --> mark it as background and vice versa.
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/img_segment_2.png)
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/img_segment_4.png)
    
  - Step 3: Refine
    - After step 2, we get the boundary of the image. To refine image segmentation alg, we create 'new scrible' base on that boundary: move to inside the boundary a little bit and move to outside the boundary a little bit to get new foreground/background scribble automatically. We also can just refine a sub-region of the boundary to get new scribles. The main idea is if we create scrible close to the boundary, it may have more information about the different between background and foreground.
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/img_segment_5.png)
    
  - Example: 
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/img_segment_6.png)
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/img_segment_7.png)
  
- Graph Cuts: (is a part of MS Office!)
  - Each pixel is a node of graph. Create 2 additional nodes: sink node (background) and source node (foreground)
  - Create edges between each node prepresent for a pixel and sink/source node = the probability of each node belong to foreground and background (can get by scribble like 'Interactive Image Segmentation').
  - Create edges between each neighbor nodes. We need 2 nodes close to each other if they both belong to background/foreground and far to each other if one belong to background and one belong to foreground --> use gradient of pixels to become weights of neighbor nodes. 
  - Now we have a graph. To seperate which pixel/node belong to foreground/background, we can use **Min Cut** alg to seperate them.
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/graph_cut_1.png)
  - Example: 
  ![](/image_and_video_processing_from_mars_to_hollywood_with_a_stop_at_the_hospital/images/graph_cut_2.png)
  
- Mumford-Shah   
  - In segmentation, we want the result close to the original image --> minimize the error
  - At the same time, we don't want the algorithm to copy the original image --> restrict by saying the result shouldn't have much edges --> minimize the penalty. 
  - Is a methodology in which we want to compromise the error of the result (approximation) and the edges (penalty).
  - Not a specific implementation. 
  - It is applied in many other fields beyond the segmentation task.
  
- Activate Contours
  - 













  
  
### Reference: 
- [Week 5](https://www.coursera.org/learn/image-processing/lecture/72Ktu/5-otsus-segmentation-with-demo-duration-14-25)
